# 产品需求文档 (PRD) - [你的奇幻小说名称] 游戏原型 (Python+Pygame)

**版本:** 0.3 (Python/Pygame Vertical Slice)
**日期:** 2025年4月7日
**作者:** Gemini (根据用户需求与授权设计)

## 1. 引言与概述

### 1.1 项目目标
本项目的目标是使用 **Python** 语言和 **Pygame** 库，开发一个**垂直切片原型 (Vertical Slice Prototype)**。该原型旨在验证核心游戏机制的可行性，包括：结合文字和少量图形元素的叙事呈现、基于选择的互动、基于冷却和速度的战斗核心循环（含召唤）、以及基础的角色扮演元素。此原型将作为未来开发完整游戏的技术基础和决策依据。

### 1.2 目标用户 (原型的)
* 开发者本人（用于技术验证和设计迭代）。
* (未来可能) 早期测试者（用于收集核心玩法反馈）。

### 1.3 核心支柱 (原型的)
* **技术验证:** 证明使用Pygame实现所需图形元素（背景、立绘、基础UI）和游戏逻辑是可行的。
* **核心循环演示:** 展示从叙事 -> 选择 -> 战斗 -> 结果反馈 -> (极简)成长的基本流程。
* **战斗机制核心:** 实现冷却/速度驱动的自动攻击、手动技能释放和召唤的基础逻辑。
* **简化与聚焦:** 功能和内容仅限于能体现核心玩法的最小集合。

## 2. 原型核心玩法循环

1.  **场景呈现 (Pygame窗口):** 显示静态背景图，展示剧情/对话文本。在特定对话中，显示角色立绘。
2.  **选项互动:** 在屏幕上绘制简单的按钮作为选项，响应玩家的鼠标点击。
3.  **战斗触发:** 根据剧情或选项，切换到战斗“模式”（可能只是UI布局变化）。
4.  **战斗过程 (Pygame窗口):**
    * 显示敌我双方的HP条。
    * 在指定区域滚动显示**战斗日志 (Text Log)**。
    * **后台代码**根据冷却/速度规则驱动自动攻击（结果更新到日志和HP条）。
    * 显示1-2个**技能按钮**，玩家点击释放技能（结果更新到日志、HP条、触发冷却/GCD）。
    * 实现一个**召唤按钮/技能**，点击后在战斗中加入一个盟友单位（显示其HP条，后台加入战斗逻辑）。
5.  **结果反馈:** 战斗结束后（根据HP判断胜负），在屏幕上显示结果信息（如“胜利！”、“获得XX经验”）。
6.  **返回叙事:** 切换回叙事场景，继续下一段文本或结束原型演示。

## 3. 原型关键特性详述 (Python + Pygame 实现)

### 3.1 叙事系统 (Prototype Narrative System)

* **内容范围:** **一个极小的、独立的场景或剧情片段。** (例如：包含1-2个场景，2-3次对话选择，一次必要的战斗)。可以使用**占位符(Placeholder)性质的内容**，不必是最终的小说情节。
* **表现形式:**
    * 使用Pygame绘制**静态背景图**。
    * 使用Pygame绘制**文本框**或直接在屏幕指定区域渲染文字（对话、描述）。
    * 在对话时，在指定位置绘制**静态角色立绘**图片（需要1-2张主角和NPC/敌人的即可）。
    * 使用Pygame绘制简单的**按钮**用于选项，并处理鼠标点击事件。
* **实现要点:** 需要编写代码管理剧情状态（当前在哪一段），根据状态加载对应文本、背景、立绘，并根据选项跳转状态。

### 3.2 角色系统 (Prototype Character System)

* **玩家角色:** 包含核心属性：**HP, MP/SP, 速度 (Speed)**, 基础攻防值。能在战斗中被修改（如HP减少）。
* **敌人角色:** 至少实现**一种**敌人类型，包含HP, 速度, 攻防值。
* **盟友角色:** 至少实现**一种**可被召唤的盟友，包含HP, 速度, 攻防值。
* **成长:** **(极简化)** 战斗胜利后可能只简单显示“获得经验值X”，**无需实现完整的升级和属性分配系统**。重点是流程能跑通。
* **实现要点:** 需要用Python类(Class)来定义角色数据结构，并在游戏主循环中管理这些对象的实例和状态。

### 3.3 战斗系统 (Prototype Combat System)

* **类型:** 基于冷却时间的半自动战斗 (Pygame实现)。
* **核心机制实现:**
    * **后台逻辑 (Python代码):**
        * 实现战斗管理器，追踪所有单位 (玩家, 敌人, 召唤物)。
        * 实现计时器，根据各单位速度和冷却规则，**计算**自动攻击的发生时间点。
        * 实现**1-2个玩家手动技能**的逻辑（效果如造成伤害、简单治疗；有固定冷却和MP消耗；触发GCD）。
        * 实现**1个召唤技能**逻辑（召唤指定盟友加入战斗，有冷却和消耗）。
        * 实现简单的**敌人AI**（例如：只会自动攻击）。
        * 实现简单的**召唤物AI**（例如：只会自动攻击）。
        * 实现伤害计算、HP更新、死亡判断。
    * **前台表现 (Pygame绘制):**
        * 绘制敌我双方的**HP条**并能更新。
        * 在固定区域**渲染滚动的战斗日志文本**，显示所有重要事件（攻击、伤害、技能释放、召唤、死亡等）。
        * 绘制**技能按钮**并响应点击，触发后台技能逻辑。
* **实现要点:** 这是原型的核心难点，需要将后台复杂的计时、状态判断逻辑与前台Pygame的绘制和输入处理结合起来。

### 3.4 物品与装备系统 (Prototype Inventory & Equipment System)

* **范围:** **(极度简化或省略)** 为了聚焦核心循环，原型**可以不包含**复杂的背包和装备系统。
* **可选简化实现:**
    * 最多实现**一种**消耗品（如HP药水），可以在战斗中通过按钮或指令使用（后台直接修改HP，无复杂背包界面）。
* **实现要点:** 如果实现，也只需后台逻辑，无需绘制复杂的背包UI。

### 3.5 非战斗互动与检定 (Prototype Non-Combat Interaction)

* **范围:** **(省略)** 原型阶段可以**不包含**非战斗技能检定，以简化流程。

### 3.6 用户界面与交互 (Prototype UI/UX)

* **界面:** 单一Pygame窗口。通过代码切换不同的“模式”或“场景”（如叙事模式、战斗模式）。
* **元素:** 使用Pygame绘制基础图形：
    * 静态图片（背景、立绘）。
    * 文本渲染（对话、日志、按钮文字）。
    * 简单形状（如矩形作为按钮背景、HP条）。
* **交互:** 主要通过**鼠标点击**Pygame窗口中绘制的按钮区域。

## 4. 美术与音效 (Prototype Art & Audio)

* **美术:** **(占位符级别即可)**
    * 1-2张静态背景图。
    * 1-2个角色的静态立绘（主角、一个敌人/NPC）。
    * 简单的UI元素视觉效果。
    * **重点是功能实现，美术资源可以用临时素材替代。**
* **音效/音乐:** **(省略)** 原型阶段可以完全不包含声音。

## 5. 技术需求 (Technical Requirements)

* **语言:** Python 3.x
* **核心库:** Pygame (需要安装)
* **开发环境:** 任意支持Python和Pygame的IDE或代码编辑器 (如 VS Code, PyCharm)。
* **平台:** 主要在开发机上运行测试 (Windows/macOS/Linux均可)。

## 6. 原型成功标准

* 游戏能够无崩溃地运行完成设定的迷你剧情片段。
* 背景、立绘、文本能够按预期显示。
* 对话选项按钮能够响应点击并导向简单的分支或战斗。
* 战斗能够开始和结束。
* 战斗中HP条能更新，战斗日志能正确显示自动攻击和至少一个手动技能、一次召唤的发生和结果。
* 核心的冷却/速度机制在后台正确计算（可以通过打印日志验证）。

---

**重要提示:**
* 这份PRD描述的是一个**功能极其有限**但包含了核心要素的**原型**。它的目的是**技术验证**和**核心玩法感受**，而非一个可玩的游戏章节。
* 完成这个原型将为你提供宝贵的经验，以判断继续投入“方向二”（不用引擎自建图形应用）开发完整游戏的可行性。
* 原型中使用的剧情、美术资源都可以是临时的占位符。

---
