# 奇幻小说TRPG游戏原型 (Python+Pygame) - 开发待办事项清单

**目标:** 构建一个功能有限但包含核心玩法的垂直切片原型。
**技术栈:** Python 3.x + Pygame 库
**提醒:** 优先保证功能实现，美术和剧情资源可使用临时占位符。建议使用Git进行版本控制。
**当前状态:** 已完成基础框架和核心功能实现，代码已推送至GitHub仓库：https://github.com/Pandasama2025/Pandasamagame

## 阶段 0: 环境设置与基础窗口 (Setup & Basic Window)

-   [x] **环境准备:**
    -   [x] 安装 Python 3.x (如果尚未安装)。
    -   [x] 使用 pip 安装 Pygame 库 (`pip install pygame`)。
    -   [x] 选择并设置好你的代码编辑器 (如 VS Code, PyCharm)。
-   [x] **项目初始化:**
    -   [x] 创建项目文件夹。
    -   [x] 初始化 Git 仓库 (`git init`)。
    -   [x] 创建主程序入口文件 (例如 `main.py`)。
-   [x] **Pygame基础窗口:**
    -   [x] 编写 `main.py`，初始化 Pygame。
    -   [x] 创建一个固定尺寸的游戏窗口。
    -   [x] 实现基础的游戏循环 (处理退出事件，保持窗口开启)。
    -   [x] 设置窗口标题。
    -   [x] 进行首次 Git 提交。

## 阶段 1: 场景管理与叙事呈现 (Scene Management & Narrative Display)

-   [x] **场景/状态管理器:**
    -   [x] 设计一个简单的机制来管理不同的游戏状态/场景（例如：`MainMenu`, `Narrative`, `Combat`）。
    -   [x] 实现根据当前状态调用不同的更新和绘制函数。
-   [x] **资源加载:**
    -   [x] 编写加载图片资源的函数 (用于背景、立绘)。
    -   [x] 编写加载字体资源的函数 (用于显示文本)。
    -   [x] 准备临时的背景图和立绘图片资源放入项目。
-   [x] **叙事场景实现:**
    -   [x] 在 `Narrative` 状态下：
        -   [x] 绘制静态背景图。
        -   [x] 在指定区域绘制剧情/对话文本（需要处理换行）。
        -   [x] 根据剧情需要，在指定位置绘制角色立绘。
        -   [x] (占位符) 加载并显示一小段固定的测试剧情文本。
-   [x] **简单选项互动:**
    -   [x] 定义按钮的数据结构（位置、大小、文本）。
    -   [x] 在 `Narrative` 状态下绘制1-2个简单的矩形按钮，并显示选项文字。
    -   [x] 处理鼠标点击事件，检测是否点击在按钮区域内。
    -   [x] 实现点击按钮后触发状态切换（例如，切换到 `Combat` 状态或下一段叙事状态）。

## 阶段 2: 核心战斗逻辑 (Combat Logic - Backend)

* **此阶段专注于 Python 代码逻辑，可以先用 `print` 输出验证，不急于绘制到 Pygame 窗口。**
-   [x] **数据结构实现:**
    -   [x] 实现 `Character` 类（或类似结构），包含 HP, MP, Speed, 攻防等属性。
    -   [x] 创建玩家、敌人、盟友的角色实例（使用测试数值）。
-   [x] **冷却与速度逻辑:**
    -   [x] 实现计时器功能（可以用 Pygame 的 `time` 模块）。
    -   [x] 根据PRD中的公式，实现计算实际攻击间隔的函数。
    -   [x] 为每个战斗单位管理其自动攻击的冷却计时器。
-   [x] **基础战斗循环逻辑:**
    -   [x] 编写 `BattleManager` 类或函数。
    -   [x] 实现管理战斗中的所有单位列表。
    -   [x] 在战斗循环中，更新所有单位的冷却计时器。
    -   [x] 当单位自动攻击冷却完成时，执行攻击（计算伤害，更新目标HP），重置冷却器。
    -   [x] 实现简单的伤害计算公式。
    -   [x] 实现HP低于等于0则判负的逻辑。
-   [x] **技能与召唤逻辑 (简化版):**
    -   [x] 定义1-2个手动技能的数据（名称、效果-如造成X点伤害、消耗、冷却时间）。
    -   [x] 实现手动释放技能的函数（检查消耗/冷却，应用效果，设置冷却）。
    -   [x] 实现GCD（公共冷却）的计时器逻辑。
    -   [x] 定义1个召唤技能的数据。
    -   [x] 实现执行召唤的函数（在战斗单位列表中添加盟友实例）。
-   [x] **简单AI:**
    -   [x] 为敌人和召唤物设定极简单的行为（例如：只会自动攻击最近/随机的目标）。

## 阶段 3: 战斗界面与逻辑集成 (Combat UI & Integration - Frontend)

-   [x] **战斗UI绘制:**
    -   [x] 在 `Combat` 状态下：
        -   [x] 绘制敌我双方（包括召唤物）的HP条（简单的矩形即可），长度能反映当前HP百分比。
        -   [x] 在指定区域创建用于显示战斗日志的文本区域。
        -   [x] 绘制1-2个技能按钮（显示技能名）。
        -   [x] (可选) 绘制简单的敌人/盟友形象占位符。
-   [x] **集成战斗逻辑与UI:**
    -   [x] 将后台 `BattleManager` 的状态（HP、冷却等）连接到UI绘制函数，使HP条能实时更新。
    -   [x] 将后台战斗事件（攻击、受伤、技能释放、召唤等）格式化为文本，添加到战斗日志显示区域（需要处理滚动或只显示最新几条）。
    -   [x] 处理技能按钮的鼠标点击事件，调用后台对应的技能释放函数。
    -   [x] 实现战斗结束逻辑（例如，显示“胜利/失败”文字，并触发状态切换回 `Narrative`）。

## 阶段 4: 整合与测试 (Final Integration & Testing)

-   [x] **流程串联:**
    -   [x] 确保从叙事场景通过选项能正确进入战斗场景。
    -   [x] 确保战斗结束后能正确返回叙事场景或结束原型。
-   [x] **测试:**
    -   [x] 完整地运行原型流程，对照PRD中的“原型成功标准”进行检查。
    -   [x] 测试所有按钮和交互是否按预期工作。
    -   [x] 检查战斗逻辑和数值计算是否大致正确（可通过日志或界面观察）。
-   [x] **简单Bug修复:** 修正原型范围内发现的明显错误。
-   [x] **代码整理 (可选):** 对代码结构进行简单的清理和注释。
-   [x] **最终提交:** 完成原型开发，进行最终的Git提交。

---

这个清单提供了一个从零开始构建Pygame原型的步骤。记住，这只是一个原型，很多地方都可以简化处理，关键是跑通核心流程并验证技术可行性。祝你编码愉快！
